<div class="kid-chat-container">
  
  <div class="chat-container">
    <div class="chat-messages" id="chatMessages">
      <div class="message ai-message">
        <span class="emoji">üëã</span>
        Hi there! I'm Cally, your friendly AI helper. You can ask me anything you want to know, and I'll try my best to help you! You can type your question or use the microphone to speak to me.
      </div>
    </div>
    
    <!-- Character Selection Dropdown -->
    <div class="character-dropdown-container" id="characterSelection">
      <div class="character-dropdown">
        <select id="characterSelect" class="character-select">
          <option value="">ü§ñ Choose Your Cally...</option>
          <% @characters.each do |character| %>
            <option value="<%= character.id %>" 
                    data-character-name="<%= character.name %>"
                    data-character-emoji="<%= character.emoji %>"
                    data-voice-settings="<%= character.voice_settings %>">
              <%= character.emoji %> <%= character.name %>
            </option>
          <% end %>
        </select>
        <button class="speaker-btn" id="characterSpeakerBtn" title="Test character voice" disabled>
          üîä
        </button>
      </div>
    </div>
    
    <!-- Voice Debug Panel (temporary) -->
    <div class="voice-debug" id="voiceDebug" style="background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; font-size: 12px; display: none;">
      <strong>üîä Voice Debug Info:</strong><br>
      <div id="debugInfo">Loading...</div>
    </div>

    <!-- Active Character Indicator -->
    <div class="active-character" id="activeCharacter" style="display: none;">
      <span class="emoji" id="activeCharacterEmoji">ü§ñ</span>
      <span id="activeCharacterName">Regular Cally</span>
      <button class="test-voice-btn" id="testVoiceBtn" title="Test this character's voice">
        üîä Test Voice
      </button>
      <button class="debug-voice-btn" id="debugVoiceBtn" title="Show voice debug info">
        üîç Debug
      </button>
    </div>
    
    <div class="status" id="status"></div>
    
    <div class="input-container">
      <button class="btn btn-voice" id="micButton" title="Click to speak">
        <span class="emoji">üé§</span>
      </button>
      
      <input type="text" 
             class="chat-input" 
             id="chatInput" 
             placeholder="Type your question here or click the microphone to speak..."
             maxlength="500">
      
      <button class="btn btn-primary" id="sendButton">
        <span class="emoji">üì§</span> Send
      </button>
      
      <button class="btn btn-speak" id="speakButton" title="Read last message aloud">
        <span class="emoji">üîä</span>
      </button>
    </div>
  </div>
</div>

<%= content_for :javascript do %>
<script>
class CallyChat {
  constructor() {
    // Get DOM elements with error checking
    this.chatMessages = document.getElementById('chatMessages');
    this.chatInput = document.getElementById('chatInput');
    this.sendButton = document.getElementById('sendButton');
    this.micButton = document.getElementById('micButton');
    this.speakButton = document.getElementById('speakButton');
    this.status = document.getElementById('status');
    this.characterSelection = document.getElementById('characterSelection');
    
    // Check if we're actually on the chat page
    if (!this.chatMessages || !this.chatInput || !this.sendButton) {
      console.log('Chat elements not found - not on chat page');
      return;
    }
    
    this.recognition = null;
    this.synthesis = window.speechSynthesis;
    this.selectedCharacter = null;
    this.currentVoiceSettings = { rate: 1.0, pitch: 1.0, voice: 'default' };
    this.availableVoices = [];
    
    // Load voices when they become available
    this.loadVoices();
    this.lastAiMessage = '';
    
    // Generate or retrieve session ID for conversation context
    this.sessionId = this.getOrCreateSessionId();
    
    this.initializeEventListeners();
    this.initializeSpeechRecognition();
    
    console.log('CallyChat initialized successfully');
  }
  
  getOrCreateSessionId() {
    // Create session ID based on current hour (like backend logic)
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    return `${year}${month}${day}_${hour}`;
  }
  
  loadVoices() {
    // Load voices when available
    const loadVoicesSync = () => {
      this.availableVoices = this.synthesis.getVoices();
      console.log('Available voices loaded:', this.availableVoices.length);
      
      // Debug: Log all available voices
      this.availableVoices.forEach((voice, index) => {
        console.log(`Voice ${index}: ${voice.name} (${voice.lang}) - ${voice.gender || 'unknown gender'}`);
      });
    };
    
    // Voices might not be loaded immediately
    if (this.synthesis.getVoices().length > 0) {
      loadVoicesSync();
    } else {
      // Wait for voices to load
      this.synthesis.onvoiceschanged = loadVoicesSync;
      
      // Fallback timeout
      setTimeout(loadVoicesSync, 1000);
    }
  }
  
  initializeEventListeners() {
    this.sendButton.addEventListener('click', () => this.sendMessage());
    this.chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.sendMessage();
      }
    });
    
    this.micButton.addEventListener('click', () => this.toggleSpeechRecognition());
    this.speakButton.addEventListener('click', () => this.speakLastMessage());
    
    // Character dropdown event listener
    const characterSelect = document.getElementById('characterSelect');
    if (characterSelect) {
      characterSelect.addEventListener('change', (e) => this.selectCharacterFromDropdown(e.target));
    }
    
    // Character speaker button listener
    const characterSpeakerBtn = document.getElementById('characterSpeakerBtn');
    if (characterSpeakerBtn) {
      characterSpeakerBtn.addEventListener('click', () => this.testCurrentCharacterVoice());
    }
    
    // Test voice button listener (in active character indicator)
    const testVoiceBtn = document.getElementById('testVoiceBtn');
    if (testVoiceBtn) {
      testVoiceBtn.addEventListener('click', () => this.testCurrentCharacterVoice());
    }
    
    // Debug voice button listener
    const debugVoiceBtn = document.getElementById('debugVoiceBtn');
    if (debugVoiceBtn) {
      debugVoiceBtn.addEventListener('click', () => this.toggleVoiceDebug());
    }
  }
  
  initializeSpeechRecognition() {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();
      this.recognition.continuous = false;
      this.recognition.interimResults = false;
      this.recognition.lang = 'en-US';
      
      this.recognition.onstart = () => {
        this.setStatus('üé§ Listening... speak now!', 'recording');
        this.micButton.disabled = true;
      };
      
      this.recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        this.chatInput.value = transcript;
        this.setStatus('‚úÖ Got it! Click send or press Enter.', 'thinking');
      };
      
      this.recognition.onerror = (event) => {
        this.setStatus('‚ùå Sorry, I couldn\'t hear you clearly. Try again!', '');
        this.micButton.disabled = false;
      };
      
      this.recognition.onend = () => {
        this.micButton.disabled = false;
        if (this.status.textContent.includes('Listening')) {
          this.setStatus('', '');
        }
      };
    } else {
      this.micButton.style.display = 'none';
      console.log('Speech recognition not supported');
    }
  }
  
  toggleSpeechRecognition() {
    if (this.recognition) {
      this.recognition.start();
    }
  }
  
  async sendMessage() {
    const message = this.chatInput.value.trim();
    if (!message) return;
    
    // Add user message to chat
    this.addMessage(message, 'user');
    this.chatInput.value = '';
    
    // Show thinking status
    this.setStatus('ü§î Thinking...', 'thinking');
    this.sendButton.disabled = true;
    
    try {
      const response = await fetch('/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        },
        body: JSON.stringify({ 
          message: message, 
          session_id: this.sessionId,
          character_id: this.selectedCharacter?.id
        })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.addMessage(data.response, 'ai');
        this.lastAiMessage = data.response;
        
        // Update voice settings if character info is returned
        if (data.character && data.character.voice_settings) {
          this.currentVoiceSettings = data.character.voice_settings;
        }
        
        this.setStatus('', '');
        
        // Don't auto-speak - only speak when user clicks speaker button
      } else {
        this.addMessage(data.error || 'Sorry, something went wrong!', 'ai');
        this.setStatus('', '');
      }
    } catch (error) {
      console.error('Error:', error);
      this.addMessage('Sorry, I had trouble connecting. Please try again!', 'ai');
      this.setStatus('', '');
    }
    
    this.sendButton.disabled = false;
  }
  
  addMessage(content, type) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    const emoji = type === 'user' ? 'üë¶' : 'ü§ñ';
    messageDiv.innerHTML = `<span class="emoji">${emoji}</span>${content}`;
    
    this.chatMessages.appendChild(messageDiv);
    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
  }
  
  selectCharacterFromDropdown(selectElement) {
    const selectedOption = selectElement.options[selectElement.selectedIndex];
    
    if (!selectedOption || !selectedOption.value) {
      // No character selected - reset
      this.selectedCharacter = null;
      this.currentVoiceSettings = { rate: 1.0, pitch: 1.0, voice: 'default' };
      
      // Hide active character indicator
      const activeCharacter = document.getElementById('activeCharacter');
      if (activeCharacter) {
        activeCharacter.style.display = 'none';
      }
      
      // Disable speaker button
      const speakerBtn = document.getElementById('characterSpeakerBtn');
      if (speakerBtn) {
        speakerBtn.disabled = true;
      }
      
      this.setStatus('Character deselected', 'character-selected');
      setTimeout(() => this.setStatus('', ''), 2000);
      return;
    }
    
    // Store selected character info
    let voiceSettings = {};
    try {
      const voiceSettingsStr = selectedOption.dataset.voiceSettings || '{}';
      console.log('üîç Raw voice settings string:', voiceSettingsStr);
      voiceSettings = JSON.parse(voiceSettingsStr);
    } catch (error) {
      console.error('‚ùå JSON parse error for voice_settings:', error);
      console.log('üîç Problematic string:', selectedOption.dataset.voiceSettings);
      voiceSettings = { rate: 1.0, pitch: 1.0, voice: 'default' }; // Fallback
    }
    
    this.selectedCharacter = {
      id: selectedOption.value,
      name: selectedOption.dataset.characterName,
      emoji: selectedOption.dataset.characterEmoji,
      voiceSettings: voiceSettings
    };
    
    // Update voice settings immediately
    this.currentVoiceSettings = this.selectedCharacter.voiceSettings;
    console.log('üé≠ Character selected:', this.selectedCharacter.name);
    console.log('üîä Voice settings updated:', this.currentVoiceSettings);
    
    // Enable speaker button
    const speakerBtn = document.getElementById('characterSpeakerBtn');
    if (speakerBtn) {
      speakerBtn.disabled = false;
    }
    
    // Update active character indicator
    const activeCharacter = document.getElementById('activeCharacter');
    const activeEmoji = document.getElementById('activeCharacterEmoji');
    const activeName = document.getElementById('activeCharacterName');
    
    if (activeCharacter && activeEmoji && activeName) {
      activeEmoji.textContent = this.selectedCharacter.emoji;
      activeName.textContent = this.selectedCharacter.name;
      activeCharacter.style.display = 'block';
    }
    
    // Test the voice immediately with a sample message
    const testMessage = this.getCharacterTestMessage(this.selectedCharacter.name);
    this.setStatus(`${this.selectedCharacter.emoji} Now talking to ${this.selectedCharacter.name}! Listen...`, 'character-selected');
    
    // Speak the test message to demonstrate voice change
    setTimeout(() => {
      this.speakMessage(testMessage);
    }, 500);
    
    // Clear status after voice test
    setTimeout(() => {
      this.setStatus('', '');
    }, 4000);
  }
  
  getCharacterTestMessage(characterName) {
    const testMessages = {
      'Regular Cally': 'Hi! I\'m your friendly helper Cally!',
      'Pirate Cally': 'Ahoy matey! Ready for adventure on the high seas?',
      'Princess Cally': 'Greetings, dear friend! Welcome to my magical kingdom!',
      'Robot Cally': 'Computing... Hello human! Fascinating data detected!',
      'Animal Expert Cally': 'Wow! Amazing creatures await us in nature!',
      'Space Explorer Cally': 'Stellar greetings, space cadet! Ready to blast off?',
      'Chef Cally': 'Hello there! Let\'s cook up something delicious together!',
      'Superhero Cally': 'Super greetings! Your amazing powers are ready for hero training!'
    };
    
    return testMessages[characterName] || 'Hello! I\'m your new character friend!';
  }
  
  testCurrentCharacterVoice() {
    if (this.selectedCharacter) {
      const testMessage = this.getCharacterTestMessage(this.selectedCharacter.name);
      this.speakMessage(testMessage);
    } else {
      this.speakMessage('Hello! Please select a character first!');
    }
  }
  
  toggleVoiceDebug() {
    const debugPanel = document.getElementById('voiceDebug');
    if (debugPanel.style.display === 'none') {
      this.showVoiceDebug();
      debugPanel.style.display = 'block';
    } else {
      debugPanel.style.display = 'none';
    }
  }
  
  showVoiceDebug() {
    const voices = this.synthesis.getVoices();
    const debugInfo = document.getElementById('debugInfo');
    
    let debugText = `<strong>Available Voices (${voices.length}):</strong><br>`;
    voices.forEach((voice, index) => {
      debugText += `${index}: ${voice.name} (${voice.lang}) - ${voice.gender || 'unknown'}<br>`;
    });
    
    debugText += `<br><strong>Current Character:</strong> ${this.selectedCharacter?.name || 'None'}<br>`;
    debugText += `<strong>Voice Settings:</strong> ${JSON.stringify(this.currentVoiceSettings)}<br>`;
    
    const selectedVoice = this.selectVoiceByType(voices, this.currentVoiceSettings.voice || 'default');
    debugText += `<strong>Selected Voice:</strong> ${selectedVoice?.name || 'None'}<br>`;
    
    debugInfo.innerHTML = debugText;
  }

  speakLastMessage() {
    if (this.lastAiMessage) {
      this.speakMessage(this.lastAiMessage);
    }
  }
  
  speakMessage(text) {
    if (this.synthesis) {
      // Cancel any ongoing speech
      this.synthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      
      // Apply character voice settings
      utterance.rate = this.currentVoiceSettings.rate || 1.0;
      utterance.pitch = this.currentVoiceSettings.pitch || 1.0;
      utterance.volume = 0.9;
      
      // Get fresh voices (important for voice changes)
      const voices = this.synthesis.getVoices();
      console.log('üîä Current character voice settings:', this.currentVoiceSettings);
      console.log('üîä Total available voices:', voices.length);
      
      // Enhanced voice selection with multiple fallbacks
      let selectedVoice = this.selectVoiceByType(voices, this.currentVoiceSettings.voice || 'default');
      
      if (selectedVoice) {
        utterance.voice = selectedVoice;
        console.log('üîä Selected voice:', selectedVoice.name, 'for', this.currentVoiceSettings.voice);
      } else {
        console.log('üîä Using default system voice');
      }
      
      utterance.onstart = () => {
        this.speakButton.disabled = true;
        this.setStatus('üîä Speaking...', 'thinking');
      };
      
      utterance.onend = () => {
        this.speakButton.disabled = false;
        this.setStatus('', '');
      };
      
      this.synthesis.speak(utterance);
    }
  }
  
  selectVoiceByType(voices, voiceType) {
    console.log('üé≠ Selecting voice for type:', voiceType);
    console.log('üé≠ Available voices:', voices.map(v => `${v.name} (${v.lang})`));
    
    // Create a more aggressive voice selection strategy
    const voiceSelectors = {
      'female': [
        // Try to find voices that are clearly female
        (v) => v.name.toLowerCase().includes('samantha'),
        (v) => v.name.toLowerCase().includes('karen'),
        (v) => v.name.toLowerCase().includes('victoria'),
        (v) => v.name.toLowerCase().includes('allison'),
        (v) => v.name.toLowerCase().includes('ava'),
        (v) => v.name.toLowerCase().includes('susan'),
        (v) => v.name.toLowerCase().includes('zira'),
        (v) => v.name.toLowerCase().includes('hazel'),
        // Google voices
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('female'),
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('us') && v.name.toLowerCase().includes('female'),
        // Fallback to any female-sounding voice
        (v) => v.name.toLowerCase().includes('female'),
        (v) => v.lang.includes('en') && v.name.toLowerCase().includes('woman'),
        // Try different indices for female voices (common pattern)
        (v, index) => index % 3 === 1 && v.lang.includes('en'), // Every 3rd voice starting from 1
        (v, index) => index % 2 === 0 && v.lang.includes('en') // Every 2nd voice starting from 0
      ],
      'male': [
        // Try to find voices that are clearly male
        (v) => v.name.toLowerCase().includes('alex'),
        (v) => v.name.toLowerCase().includes('daniel'),
        (v) => v.name.toLowerCase().includes('tom'),
        (v) => v.name.toLowerCase().includes('fred'),
        (v) => v.name.toLowerCase().includes('ralph'),
        (v) => v.name.toLowerCase().includes('david'),
        (v) => v.name.toLowerCase().includes('mark'),
        // Google voices
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('male'),
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('us') && v.name.toLowerCase().includes('male'),
        // Fallback to any male-sounding voice
        (v) => v.name.toLowerCase().includes('male'),
        (v) => v.lang.includes('en') && v.name.toLowerCase().includes('man'),
        // Try different indices for male voices
        (v, index) => index % 3 === 2 && v.lang.includes('en'), // Every 3rd voice starting from 2
        (v, index) => index % 2 === 1 && v.lang.includes('en') // Every 2nd voice starting from 1
      ],
      'default': [
        // Best quality voices first
        (v) => v.name.toLowerCase().includes('google') && v.lang.includes('en-us'),
        (v) => v.name.toLowerCase().includes('alex'),
        (v) => v.name.toLowerCase().includes('samantha'),
        (v) => v.name.toLowerCase().includes('google'),
        (v) => v.lang.includes('en-us'),
        (v) => v.lang.includes('en')
      ]
    };
    
    const selectors = voiceSelectors[voiceType] || voiceSelectors['default'];
    
    // Try each selector in priority order
    for (const selector of selectors) {
      const voice = voices.find((v, index) => selector(v, index));
      if (voice) {
        console.log(`üéØ Found voice: ${voice.name} for ${voiceType}`);
        return voice;
      }
    }
    
    // Ultimate fallback - just pick a different voice based on voice type
    if (voiceType === 'female' && voices.length > 1) {
      const femaleVoice = voices[1]; // Try second voice
      console.log(`üîÑ Female fallback voice: ${femaleVoice.name}`);
      return femaleVoice;
    } else if (voiceType === 'male' && voices.length > 2) {
      const maleVoice = voices[2]; // Try third voice
      console.log(`üîÑ Male fallback voice: ${maleVoice.name}`);
      return maleVoice;
    }
    
    // Final fallback - first English voice
    const fallback = voices.find(v => v.lang.includes('en'));
    if (fallback) {
      console.log(`üîÑ Final fallback voice: ${fallback.name}`);
      return fallback;
    }
    
    console.log('‚ö†Ô∏è No suitable voice found, using system default');
    return null;
  }
  
  setStatus(message, className) {
    if (this.status) {
      this.status.textContent = message;
      this.status.className = `status ${className}`;
    }
  }
}

// Initialize Cally when the page loads - handle both initial load and Turbo navigation
function initializeCallyChat() {
  // Only initialize if we're on the chat page and don't already have an instance
  if (document.getElementById('chatMessages') && !window.callyChat) {
    console.log('Initializing CallyChat...');
    window.callyChat = new CallyChat();
  }
}

// Clean up existing instance
function cleanupCallyChat() {
  if (window.callyChat) {
    console.log('Cleaning up CallyChat...');
    // Clean up speech recognition if active
    if (window.callyChat.recognition) {
      try {
        window.callyChat.recognition.abort();
      } catch (e) {
        // Ignore errors during cleanup
      }
    }
    window.callyChat = null;
  }
}

// Handle both regular page loads and Turbo navigation
document.addEventListener('DOMContentLoaded', initializeCallyChat);
document.addEventListener('turbo:load', initializeCallyChat);

// Clean up when leaving the page
document.addEventListener('turbo:before-visit', cleanupCallyChat);
document.addEventListener('turbo:before-cache', cleanupCallyChat);
</script>
<% end %>
