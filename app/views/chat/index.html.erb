<div class="kid-chat-container">
  
  <div class="chat-container">
    <div class="chat-messages" id="chatMessages">
      <div class="message ai-message">
        <span class="emoji">ðŸ‘‹</span>
        Hi there! I'm Cally, your friendly AI helper. You can ask me anything you want to know, and I'll try my best to help you! You can type your question or use the microphone to speak to me.
      </div>
    </div>
    
    <!-- Character Selection Dropdown -->
    <div class="character-dropdown-container" id="characterSelection">
      <div class="character-dropdown">
        <select id="characterSelect" class="character-select">
          <option value="">ðŸ¤– Choose Your Cally...</option>
          <% @characters.each do |character| %>
            <option value="<%= character.id %>" 
                    data-character-name="<%= character.name %>"
                    data-character-emoji="<%= character.emoji %>"
                    data-voice-settings="<%= character.voice_settings %>">
              <%= character.emoji %> <%= character.name %>
            </option>
          <% end %>
        </select>
        <button class="speaker-btn" id="characterSpeakerBtn" title="Test character voice" disabled>
          ðŸ”Š
        </button>
      </div>
    </div>
    
    <!-- Active Character Indicator -->
    <div class="active-character" id="activeCharacter" style="display: none;">
      <span class="emoji" id="activeCharacterEmoji">ðŸ¤–</span>
      <span id="activeCharacterName">Regular Cally</span>
      <button class="test-voice-btn" id="testVoiceBtn" title="Test this character's voice">
        ðŸ”Š Test Voice
      </button>
    </div>
    
    <div class="status" id="status"></div>
    
    <div class="input-container">
      <button class="btn btn-voice" id="micButton" title="Click to speak">
        <span class="emoji">ðŸŽ¤</span>
      </button>
      
      <input type="text" 
             class="chat-input" 
             id="chatInput" 
             placeholder="Type your question here or click the microphone to speak..."
             maxlength="500">
      
      <button class="btn btn-primary" id="sendButton">
        <span class="emoji">ðŸ“¤</span> Send
      </button>
      
      <button class="btn btn-speak" id="speakButton" title="Read last message aloud">
        <span class="emoji">ðŸ”Š</span>
      </button>
    </div>
  </div>
</div>

<%= content_for :javascript do %>
<script>
class CallyChat {
  constructor() {
    // Get DOM elements with error checking
    this.chatMessages = document.getElementById('chatMessages');
    this.chatInput = document.getElementById('chatInput');
    this.sendButton = document.getElementById('sendButton');
    this.micButton = document.getElementById('micButton');
    this.speakButton = document.getElementById('speakButton');
    this.status = document.getElementById('status');
    this.characterSelection = document.getElementById('characterSelection');
    
    // Check if we're actually on the chat page
    if (!this.chatMessages || !this.chatInput || !this.sendButton) {
      console.log('Chat elements not found - not on chat page');
      return;
    }
    
    this.recognition = null;
    this.synthesis = window.speechSynthesis;
    this.selectedCharacter = null;
    this.currentVoiceSettings = { rate: 1.0, pitch: 1.0, voice: 'default' };
    this.availableVoices = [];
    
    // Load voices when they become available
    this.loadVoices();
    this.lastAiMessage = '';
    
    // Generate or retrieve session ID for conversation context
    this.sessionId = this.getOrCreateSessionId();
    
    this.initializeEventListeners();
    this.initializeSpeechRecognition();
    
    console.log('CallyChat initialized successfully');
  }
  
  getOrCreateSessionId() {
    // Create session ID based on current hour (like backend logic)
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    return `${year}${month}${day}_${hour}`;
  }
  
  loadVoices() {
    // Load voices when available
    const loadVoicesSync = () => {
      this.availableVoices = this.synthesis.getVoices();
    };
    
    // Voices might not be loaded immediately
    if (this.synthesis.getVoices().length > 0) {
      loadVoicesSync();
    } else {
      // Wait for voices to load
      this.synthesis.onvoiceschanged = loadVoicesSync;
      
      // Fallback timeout
      setTimeout(loadVoicesSync, 1000);
    }
  }
  
  initializeEventListeners() {
    this.sendButton.addEventListener('click', () => this.sendMessage());
    this.chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.sendMessage();
      }
    });
    
    this.micButton.addEventListener('click', () => this.toggleSpeechRecognition());
    this.speakButton.addEventListener('click', () => this.speakLastMessage());
    
    // Character dropdown event listener
    const characterSelect = document.getElementById('characterSelect');
    if (characterSelect) {
      characterSelect.addEventListener('change', (e) => this.selectCharacterFromDropdown(e.target));
    }
    
    // Character speaker button listener
    const characterSpeakerBtn = document.getElementById('characterSpeakerBtn');
    if (characterSpeakerBtn) {
      characterSpeakerBtn.addEventListener('click', () => this.testCurrentCharacterVoice());
    }
    
    // Test voice button listener (in active character indicator)
    const testVoiceBtn = document.getElementById('testVoiceBtn');
    if (testVoiceBtn) {
      testVoiceBtn.addEventListener('click', () => this.testCurrentCharacterVoice());
    }
  }
  
  initializeSpeechRecognition() {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();
      this.recognition.continuous = false;
      this.recognition.interimResults = false;
      this.recognition.lang = 'en-US';
      
      this.recognition.onstart = () => {
        this.setStatus('ðŸŽ¤ Listening... speak now!', 'recording');
        this.micButton.disabled = true;
      };
      
      this.recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        this.chatInput.value = transcript;
        this.setStatus('âœ… Got it! Click send or press Enter.', 'thinking');
      };
      
      this.recognition.onerror = (event) => {
        this.setStatus('âŒ Sorry, I couldn\'t hear you clearly. Try again!', '');
        this.micButton.disabled = false;
      };
      
      this.recognition.onend = () => {
        this.micButton.disabled = false;
        if (this.status.textContent.includes('Listening')) {
          this.setStatus('', '');
        }
      };
    } else {
      this.micButton.style.display = 'none';
      console.log('Speech recognition not supported');
    }
  }
  
  toggleSpeechRecognition() {
    if (this.recognition) {
      this.recognition.start();
    }
  }
  
  async sendMessage() {
    const message = this.chatInput.value.trim();
    if (!message) return;
    
    // Add user message to chat
    this.addMessage(message, 'user');
    this.chatInput.value = '';
    
    // Show thinking status
    this.setStatus('ðŸ¤” Thinking...', 'thinking');
    this.sendButton.disabled = true;
    
    try {
      const response = await fetch('/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        },
        body: JSON.stringify({ 
          message: message, 
          session_id: this.sessionId,
          character_id: this.selectedCharacter?.id
        })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.addMessage(data.response, 'ai');
        this.lastAiMessage = data.response;
        
        // Update voice settings if character info is returned
        if (data.character && data.character.voice_settings) {
          this.currentVoiceSettings = data.character.voice_settings;
        }
        
        this.setStatus('', '');
        
        // Don't auto-speak - only speak when user clicks speaker button
      } else {
        this.addMessage(data.error || 'Sorry, something went wrong!', 'ai');
        this.setStatus('', '');
      }
    } catch (error) {
      console.error('Error:', error);
      this.addMessage('Sorry, I had trouble connecting. Please try again!', 'ai');
      this.setStatus('', '');
    }
    
    this.sendButton.disabled = false;
  }
  
  addMessage(content, type) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    const emoji = type === 'user' ? 'ðŸ‘¦' : 'ðŸ¤–';
    messageDiv.innerHTML = `<span class="emoji">${emoji}</span>${content}`;
    
    this.chatMessages.appendChild(messageDiv);
    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
  }
  
  selectCharacterFromDropdown(selectElement) {
    const selectedOption = selectElement.options[selectElement.selectedIndex];
    
    if (!selectedOption || !selectedOption.value) {
      // No character selected - reset
      this.selectedCharacter = null;
      this.currentVoiceSettings = { rate: 1.0, pitch: 1.0, voice: 'default' };
      
      // Hide active character indicator
      const activeCharacter = document.getElementById('activeCharacter');
      if (activeCharacter) {
        activeCharacter.style.display = 'none';
      }
      
      // Disable speaker button
      const speakerBtn = document.getElementById('characterSpeakerBtn');
      if (speakerBtn) {
        speakerBtn.disabled = true;
      }
      
      this.setStatus('Character deselected', 'character-selected');
      setTimeout(() => this.setStatus('', ''), 2000);
      return;
    }
    
    // Store selected character info
    let voiceSettings = {};
    try {
      let voiceSettingsStr = selectedOption.dataset.voiceSettings || '{}';
      
      // Fix HTML encoding issues
      voiceSettingsStr = voiceSettingsStr.replace(/&quot;/g, '"');
      
      voiceSettings = JSON.parse(voiceSettingsStr);
    } catch (error) {
      voiceSettings = { rate: 1.0, pitch: 1.0, voice: 'default' }; // Fallback
    }
    
    this.selectedCharacter = {
      id: selectedOption.value,
      name: selectedOption.dataset.characterName,
      emoji: selectedOption.dataset.characterEmoji,
      voiceSettings: voiceSettings
    };
    
    // Update voice settings immediately
    this.currentVoiceSettings = this.selectedCharacter.voiceSettings;
    
    // Enable speaker button
    const speakerBtn = document.getElementById('characterSpeakerBtn');
    if (speakerBtn) {
      speakerBtn.disabled = false;
    }
    
    // Update active character indicator
    const activeCharacter = document.getElementById('activeCharacter');
    const activeEmoji = document.getElementById('activeCharacterEmoji');
    const activeName = document.getElementById('activeCharacterName');
    
    if (activeCharacter && activeEmoji && activeName) {
      activeEmoji.textContent = this.selectedCharacter.emoji;
      activeName.textContent = this.selectedCharacter.name;
      activeCharacter.style.display = 'block';
    }
    
    // Test the voice immediately with a sample message
    const testMessage = this.getCharacterTestMessage(this.selectedCharacter.name);
    this.setStatus(`${this.selectedCharacter.emoji} Now talking to ${this.selectedCharacter.name}! Listen...`, 'character-selected');
    
    // Speak the test message to demonstrate voice change
    setTimeout(() => {
      this.speakMessage(testMessage);
    }, 500);
    
    // Clear status after voice test
    setTimeout(() => {
      this.setStatus('', '');
    }, 4000);
  }
  
  getCharacterTestMessage(characterName) {
    const testMessages = {
      'Regular Cally': 'Hi! I\'m your friendly helper Cally!',
      'Pirate Cally': 'Ahoy matey! Ready for adventure on the high seas?',
      'Princess Cally': 'Greetings, dear friend! Welcome to my magical kingdom!',
      'Robot Cally': 'Computing... Hello human! Fascinating data detected!',
      'Animal Expert Cally': 'Wow! Amazing creatures await us in nature!',
      'Space Explorer Cally': 'Stellar greetings, space cadet! Ready to blast off?',
      'Chef Cally': 'Hello there! Let\'s cook up something delicious together!',
      'Superhero Cally': 'Super greetings! Your amazing powers are ready for hero training!'
    };
    
    return testMessages[characterName] || 'Hello! I\'m your new character friend!';
  }
  
  testCurrentCharacterVoice() {
    if (this.selectedCharacter) {
      const testMessage = this.getCharacterTestMessage(this.selectedCharacter.name);
      this.speakMessage(testMessage);
    } else {
      this.speakMessage('Hello! Please select a character first!');
    }
  }
  

  speakLastMessage() {
    if (this.lastAiMessage) {
      this.speakMessage(this.lastAiMessage);
    }
  }
  
  speakMessage(text) {
    if (this.synthesis) {
      // Cancel any ongoing speech
      this.synthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      
      // Apply character voice settings
      utterance.rate = this.currentVoiceSettings.rate || 1.0;
      utterance.pitch = this.currentVoiceSettings.pitch || 1.0;
      utterance.volume = 0.9;
      
      // Get fresh voices (important for voice changes)
      const voices = this.synthesis.getVoices();
      
      // Enhanced voice selection with multiple fallbacks
      let selectedVoice = this.selectVoiceByType(voices, this.currentVoiceSettings.voice || 'default');
      
      if (selectedVoice) {
        utterance.voice = selectedVoice;
      }
      
      utterance.onstart = () => {
        this.speakButton.disabled = true;
        this.setStatus('ðŸ”Š Speaking...', 'thinking');
      };
      
      utterance.onend = () => {
        this.speakButton.disabled = false;
        this.setStatus('', '');
      };
      
      this.synthesis.speak(utterance);
    }
  }
  
  selectVoiceByType(voices, voiceType) {
    
    // Create a more aggressive voice selection strategy
    const voiceSelectors = {
      'female': [
        // Try to find voices that are clearly female
        (v) => v.name.toLowerCase().includes('samantha'),
        (v) => v.name.toLowerCase().includes('karen'),
        (v) => v.name.toLowerCase().includes('victoria'),
        (v) => v.name.toLowerCase().includes('allison'),
        (v) => v.name.toLowerCase().includes('ava'),
        (v) => v.name.toLowerCase().includes('susan'),
        (v) => v.name.toLowerCase().includes('zira'),
        (v) => v.name.toLowerCase().includes('hazel'),
        // Google voices
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('female'),
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('us') && v.name.toLowerCase().includes('female'),
        // Fallback to any female-sounding voice
        (v) => v.name.toLowerCase().includes('female'),
        (v) => v.lang.includes('en') && v.name.toLowerCase().includes('woman'),
        // Try different indices for female voices (common pattern)
        (v, index) => index % 3 === 1 && v.lang.includes('en'), // Every 3rd voice starting from 1
        (v, index) => index % 2 === 0 && v.lang.includes('en') // Every 2nd voice starting from 0
      ],
      'male': [
        // Try to find voices that are clearly male
        (v) => v.name.toLowerCase().includes('alex'),
        (v) => v.name.toLowerCase().includes('daniel'),
        (v) => v.name.toLowerCase().includes('tom'),
        (v) => v.name.toLowerCase().includes('fred'),
        (v) => v.name.toLowerCase().includes('ralph'),
        (v) => v.name.toLowerCase().includes('david'),
        (v) => v.name.toLowerCase().includes('mark'),
        // Google voices
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('male'),
        (v) => v.name.toLowerCase().includes('google') && v.name.toLowerCase().includes('us') && v.name.toLowerCase().includes('male'),
        // Fallback to any male-sounding voice
        (v) => v.name.toLowerCase().includes('male'),
        (v) => v.lang.includes('en') && v.name.toLowerCase().includes('man'),
        // Try different indices for male voices
        (v, index) => index % 3 === 2 && v.lang.includes('en'), // Every 3rd voice starting from 2
        (v, index) => index % 2 === 1 && v.lang.includes('en') // Every 2nd voice starting from 1
      ],
      'default': [
        // Best quality voices first
        (v) => v.name.toLowerCase().includes('google') && v.lang.includes('en-us'),
        (v) => v.name.toLowerCase().includes('alex'),
        (v) => v.name.toLowerCase().includes('samantha'),
        (v) => v.name.toLowerCase().includes('google'),
        (v) => v.lang.includes('en-us'),
        (v) => v.lang.includes('en')
      ]
    };
    
    const selectors = voiceSelectors[voiceType] || voiceSelectors['default'];
    
    // Try each selector in priority order
    for (const selector of selectors) {
      const voice = voices.find((v, index) => selector(v, index));
      if (voice) {
        return voice;
      }
    }
    
    // Ultimate fallback - just pick a different voice based on voice type
    if (voiceType === 'female' && voices.length > 1) {
      return voices[1]; // Try second voice
    } else if (voiceType === 'male' && voices.length > 2) {
      return voices[2]; // Try third voice
    }
    
    // Final fallback - first English voice
    const fallback = voices.find(v => v.lang.includes('en'));
    if (fallback) {
      return fallback;
    }
    
    return null;
  }
  
  setStatus(message, className) {
    if (this.status) {
      this.status.textContent = message;
      this.status.className = `status ${className}`;
    }
  }
}

// Initialize Cally when the page loads - handle both initial load and Turbo navigation
function initializeCallyChat() {
  // Only initialize if we're on the chat page and don't already have an instance
  if (document.getElementById('chatMessages') && !window.callyChat) {
    console.log('Initializing CallyChat...');
    window.callyChat = new CallyChat();
  }
}

// Clean up existing instance
function cleanupCallyChat() {
  if (window.callyChat) {
    console.log('Cleaning up CallyChat...');
    // Clean up speech recognition if active
    if (window.callyChat.recognition) {
      try {
        window.callyChat.recognition.abort();
      } catch (e) {
        // Ignore errors during cleanup
      }
    }
    window.callyChat = null;
  }
}

// Handle both regular page loads and Turbo navigation
document.addEventListener('DOMContentLoaded', initializeCallyChat);
document.addEventListener('turbo:load', initializeCallyChat);

// Clean up when leaving the page
document.addEventListener('turbo:before-visit', cleanupCallyChat);
document.addEventListener('turbo:before-cache', cleanupCallyChat);
</script>
<% end %>
